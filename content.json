{"pages":[{"title":"About me","text":"Careers NHN Software Developer in PLAYMUSEUM Contact E-mail : spyrocket12@naver.com GitHub : https://github.com/CrazyThink Technical Skills Java Spring Framework Vue.js MySQL, Oracle Project 프로젝트 목록 Awards 2017.11.16. 교내 IT융합 프로그래밍 경시대회 (금상) 2016.11.25. 교내 IT융합 프로그래밍 경시대회 (대상) 2017~2018 (기타) 창업동아리 활동 수상 10건 Patent (등록) 10-1874382 휴대용 보관 팩","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"CUDA_INDEX","text":"1D grid of 1D blocks1234__device__int getGlobalIdx_1D_1D(){ return blockId.x * blockDim.x + threadIdx.x;} 1D grid of 2D blocks12345__device__int getGlobalIdx_1D_2D(){ return blockIdx.x * blockDim.x * blockDim.y + threadIdx.y * blockDim.x + threadIdx.x;} 1D grid of 3D blocks123456__device__int getGlobalIdx_1D_3D(){ return blockIdx.x * blockDim.x * blockDim.y * blockDim.z + threadIdx.z * blockDim.y * blockDim.x + threadIdx.y * blockDim.x + threadIdx.x;} 2D grid of 1D blocks12345__device__ int getGlobalIdx_2D_1D(){ int blockId = blockIdx.y * gridDim.x + blockIdx.x; int threadId = blockId * blockDim.x + threadIdx.x; return threadId;} 2D grid of 2D blocks1234567__device__int getGlobalIdx_2D_2D(){ int blockId = blockIdx.x + blockIdx.y * gridDim.x; int threadId = blockId * (blockDim.x * blockDim.y) + (threadIdx.y * blockDim.x) + threadIdx.x; return threadId;} 2D grid of 3D blocks12345678__device__int getGlobalIdx_2D_3D(){ int blockId = blockIdx.x + blockIdx.y * gridDim.x; int threadId = blockId * (blockDim.x * blockDim.y * blockDim.z) + (threadIdx.z * (blockDim.x * blockDim.y)) + (threadIdx.y * blockDim.x) + threadIdx.x; return threadId;} 3D grid of 1D blocks1234567__device__int getGlobalIdx_3D_1D(){ int blockId = blockIdx.x + blockIdx.y * gridDim.x + gridDim.x * gridDim.y * blockIdx.z; int threadId = blockId * blockDim.x + threadIdx.x; return threadId;} 3D grid of 2D blocks12345678__device__int getGlobalIdx_3D_2D(){ int blockId = blockIdx.x + blockIdx.y * gridDim.x + gridDim.x * gridDim.y * blockIdx.z; int threadId = blockId * (blockDim.x * blockDim.y) + (threadIdx.y * blockDim.x) + threadIdx.x; return threadId;} 3D grid of 3D blocks123456789__device__int getGlobalIdx_3D_3D(){ int blockId = blockIdx.x + blockIdx.y * gridDim.x + gridDim.x * gridDim.y * blockIdx.z; int threadId = blockId * (blockDim.x * blockDim.y * blockDim.z) + (threadIdx.z * (blockDim.x * blockDim.y)) + (threadIdx.y * blockDim.x) + threadIdx.x; return threadId;}","link":"/2018/05/27/CUDA-INDEX/"},{"title":"Test에서 Fixture란?","text":"정의테스트를 수행하는 데 필요한 정보나 오브젝트 설명일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before메소드를 이용해 생성해두면 편리하다. 예시12345678910111213public class UserDaoTest { private UserDao dao; //Fixture private User user1; //Fixture private User user2; //Fixture @Before public void setUp() { ... this.user1 = new User(&quot;rookie&quot;, &quot;루키맨&quot;, &quot;spring1장&quot;); this.user2 = new User(&quot;rokie&quot;, &quot;로키맨&quot;, &quot;spring2장&quot;); } ...}","link":"/2019/02/13/Fixture/"},{"title":"NHN 1주차 - 입문교육","text":"요약설레는 마음으로 회사에 가서 교육 들으며 조별 활동을 진행했다.조금은 힘들었지만 소중한 사람들을 얻을 수 있었기에 좋은 경험이었다.꽃등심은 맛있었다. :) 입사 첫날.아침이 밝았다. 오늘은 내가 NHN 신입으로 첫 출근을 하는 날이다. 나와 같이 입사하는 동기들이 궁금했다. 어떤 친구들일까? 내가 잘할 수 있을까? 머릿속에 궁금증이 가득한 채 문밖으로 첫 발걸음을 내디뎠다.그렇게 40분 후, 회사에 도착해서 사원증을 받아 교육장으로 향했다.“아, 내가 정말 붙은 게 맞나…?”아직 실감이 나지 않았다.교육장에 들어서자, 사람들이 많이 와있었다. 다들 서로 어색해 보였다. 조용히 빵을 먹는 사람. 조용히 스마트폰만 보는 사람. 모두 다른 행동을 하고 있었지만, 아마 ‘설렌다…’는 마음은 모두 같았으리라.나도 김밥 하나를 들고 자리에 앉았다. 아침까지 챙겨주는 회사가 어디 있을까. 입사를 진심으로 축하합니다. 스크린에 글이 보였다. 나 정말 합격했나보다. 신기했다. 좋았다. 기뻤다.옆 사람과 인사도 나누고, 조금 친해지려던 참이었는데 입문교육이 시작되었다.오후 5시까지 이어진 입문교육…하루종일 교육을 들으려니까 지치기 시작했지만, 이어서 조별 활동이 시작되었고 쉴 틈도 없이 밤 9시 반이 되어 첫날 일정이 끝났다. 첫날부터 다들 힘들었고, 집에 도착하니 밤 10시가 넘었다. 씻고 정리 좀 하다 보니 시간이 늦어서 바로 잠이 들었다. 입사 둘째 날.하루종일 교육들었다.덕분에 몸은 조금 피곤했지만, 우리 회사에 대해 더욱 잘 알 수 있는 계기가 되었고, 더욱 똑똑한 열정을 가질 수 있었다. 입사 셋째 날.아침 교육을 듣고, 오후에는 강남 스탬프 투어를 했다.우리 조는 협업 열정 끈기 소통 신뢰 를 바탕으로 열심히 스탬프 투어에 임했고, 큰 기대는 하지 않았지만 좋은 결과를 얻었다. 덕분에 조원들과 더욱 친해졌다. 입사 넷째 날.조별로 맡은 서비스를 발표하고, 셋째 날에 했던 스탬프 투어와 점수를 합쳐서 시상식을 진행했다. 주말을 투자한 덕분인지 좋은 결과를 얻었고, 입문교육에서 많은 것을 배울 수 있어서 좋은 경험이었다. ^______________^","link":"/2019/01/10/D-Week1/"},{"title":"Least Recently Used","text":"구현123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() { list&lt;int&gt; cache; int item; int cacheSize = 3; //Cache Size int count = 0; //Cache Miss 횟수 while(true){ cin &gt;&gt; item; if(cin.fail()) break; cache.remove(item); if(cache.size() &lt; cacheSize) cache.push_back(item); else{ cout &lt;&lt; cache.front() &lt;&lt; endl; //교체가 일어난 item 출력 cache.pop_front(); cache.push_back(item); cache++; } } if(count == 0) cout &lt;&lt; 0 &lt;&lt; endl; //Cache Miss가 0이면 0 출력 return 0;}","link":"/2018/09/28/LRU/"},{"title":"ListContainer","text":"list의 사용#include&lt;list&gt;list&lt;[Data Type]&gt; [변수 이름]; 예시) list&lt;int&gt; lt1; list&lt;string&gt; lt2; list 반복자list&lt;[Data Type]&gt;::iterator [변수 이름]; list 생성자1234567list lt; //비어있는 list컨테이너 lt를 생성합니다.list lt(10); //default(0)값으로 초기화 된 원소 10개를 가진 list를 생성합니다.list lt(3, 2); //2값으로 초기화 된 원소 3개를 가진 list를 생성합니다.list lt2(lt1); //list lt1을 lt2로 복사합니다. list의 멤버 함수1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556lt.assign(3, 4); //4로 초기화된 3개의 원소를 할당한다.lt.front(); //맨 앞의 원소를 반환(return), 참조 합니다.lt.back(); //맨 뒤의 원소를 반환(return), 참조 합니다.lt.begin(); //맨 앞의 원소를 가리키는 iterator를 반환합니다.lt.end(); //맨 마지막의 다음 원소를 가리키는 iterator를 반환합니다.lt.rbegin(); //뒤에서부터 원소를 순차적으로 접근할때 편리하게 쓰입니다.lt.rend(); //뒤에서부터 원소를 순차적으로 접근할때 편리하게 쓰입니다.lt.push_back(k); //뒤쪽으로 원소 k 를 삽입합니다.lt.push_front(k); //앞쪽으로 원소 k 를 삽입합니다.lt.pop_back(); //맨 마지막 원소를 제거합니다.lt.pop_front(); //맨 첫번째 원소를 제거합니다.lt.insert(iter, k); //iter가 가리키는 위치에 원소 k를 삽입합니다. 삽입한 원소를 가리키는 iterator를 반환합니다.lt.erase(iter); //iterator가 가리키는 원소를 삭제합니다.반환값은 삭제한 원소의 다음 원소를 가리키는 iterator를 반환합니다.lt.size(); //원소의 개수를 반환합니다.lt.remove(k); //k와 같은 원소를 모두 제거합니다.lt.remove_if(Predicate); //단항 조건자 predicate에 해당하는 원소를 모두 제거합니다.bool predicate(int num){ return num&gt;=100 &amp;&amp; num&lt;=200;}lt.reverse(); //원소들의 순차열을 뒤집습니다.lt.sort(); //모든 원소를 default(오름차순)으로 정렬합니다.lt.sort(greater&lt;[Data Type]&gt;()); //모든 원소를 내림차순으로 정렬합니다.lt2.swap(lt1); //lt2와 lt1을 swap(바꿉)니다.lt2.splice(iter2, lt1); //lt2에서 iter2이 가리키는 곳에 lt1의 모든 원소를 잘라 붙입니다.lt2.splice(iter2, lt1, iter1); //lt2의 iter2가 가리키는 곳에 lt1의 iter1이 가리키는 원소를 잘라 붙입니다.lt2.splice(iter2, lt1, iter1_1, iter1_2); // lt2의 iter2가 가리키는 곳에 lt1의 [iter1_1 , iter1_2) 까지의 원소를 잘라 붙입니다.lt.unique(); //인접한(양옆의) 원소가 같으면 유일하게 만듭니다.(하나만빼고 삭제)lt2.merge(lt1);//lt1을 lt2내부로 합병 정렬합니다. 기준은 default 오름차순 입니다. //두번째 파라미터로 이항 조건자가 올 수 있습니다. 그때는 그 기준으로 정렬합니다.","link":"/2018/09/28/ListContainer/"},{"title":"Linux에 색상 출력하기","text":"Terminal에 미리보기형식 지정1234567&gt; for code in {30..37}; do \\echo -en &quot;\\033[${code}m&quot;'\\\\033['&quot;$code&quot;'m'&quot;\\033[0m&quot;; \\echo -en &quot; \\033[$code;1m&quot;'\\\\033['&quot;$code&quot;';1m'&quot;\\033[0m&quot;; \\echo -en &quot; \\033[$code;3m&quot;'\\\\033['&quot;$code&quot;';3m'&quot;\\033[0m&quot;; \\echo -en &quot; \\033[$code;4m&quot;'\\\\033['&quot;$code&quot;';4m'&quot;\\033[0m&quot;; \\echo -e &quot; \\033[$((code+60))m&quot;'\\\\033['&quot;$((code+60))&quot;'m'&quot;\\033[0m&quot;; \\done 형식 종류 값 Bold 1 Underscore 4 Background 3 255 색상 출력123&gt; for code in {0..255} do echo -e &quot;\\033[38;5;${code}m&quot;'\\\\033[38;5;'&quot;$code&quot;m&quot;\\033[0m&quot; done 색상 종류 범위 Basic 8 colors 30~37 Basic “high contrast” colors 90~97 xerm-256 colors 0~255 사용법이 코드를 사용하기 전에 위에 있는 코드를 Terminal에 실행 후 색상을 확인하고 사용 바람!! bash1$ echo -e &quot;\\033[38;5;[0~255]m[contents]\\033[0m&quot; C(gcc)[0~255] 중에서 하나 골라서 입력[contents] 부분에 내용 입력 12345678910111213//방법1fprintf(stderr, &quot;\\033[38;5;[0~255]m[contents]\\033[0m&quot;);//방법2printf(&quot;\\033[38;5;[0~255]m[contents]\\033[0m&quot;);//방법3printf(&quot;\\033[38;5;[0~255]m&quot;); //글자색 변경printf(&quot;[contents]&quot;); //내용 입력printf(&quot;\\033[0m&quot;); //원래 색(흰색)으로 변경//방법4 - 색상&amp;밑줄printf(&quot;\\033[33;4m[contents]\\033[0m&quot;); &lt;참조&gt; http://jafrog.com/2013/11/23/colors-in-terminal.html","link":"/2018/05/24/LinuxColor/"},{"title":"(개인 프로젝트) 유니티로 만든 슈팅게임 A","text":"소개 인원 : 1인 담당 : 프로그램 구현 전체 개발 환경 : Unity 마켓 링크 : 슈팅게임 A 내용유니티 공부하면서 간단하게 만들어본 슈팅게임입니다. 3000점 마다 “현재 스코어/1000”의 체력을 가진 보스 생성 6000점 마다 발사 속도가 증가하는 파워업 아이템 생성 10000점 마다 목숨을 1만큼 올려주는 하트 아이템 생성 12000점 마다 스테이지 1 증가, 적군의 체력이 1만큼 상승 60000점이 되면 게임 클리어 어려웠던 점게임을 하면서 불편했던 점은 많았지만, 그것들을 직접 구현하려고 하다 보니, 기능 하나를 추가하는데 하루가 지나기도 했습니다. 게다가 프로그래밍만 하면 될 것 같았지만, 그림 편집도 필요했고, 음악 제작도 필요해서 직접 공부하느라 힘들었습니다. 가장 어려웠던 것은 적이 총알을 발사할 때 플레이어를 향하도록 하는 것이었는데, 적 유닛 하나하나에 방향을 지정하는 방법을 결국 알아내지 못했습니다. 그래서 어쩔 수 없이 모든 적이 무작위의 각도로 한 방향으로만 총알을 쏘고 있습니다. 배운 점이렇게 힘든 과정 끝에 게임을 완성하고 나니 저만의 것이 하나 탄생한 것 같았습니다. 정말로 Unity를 이용해 게임을 완성하는데 2주도 안 걸렸고, 주위 친구들도 게임을 직접 플레이하며 즐거워하는 모습을 보니 성취감도 느껴졌습니다. 그 당시에 게임 개발을 위해 노력했던 것은 지금의 실력이 있는 저로 성장한 좋은 계기가 되었습니다.","link":"/2016/10/04/P-A/"},{"title":"(개인 프로젝트) CUDA를 이용해서 멀티 스레드로 작동하는 Image Filter 프로그램","text":"소개 인원 : 1인 담당 : 프로그램 구현 전체 개발 환경 : Visual Studio 2015, CUDA 9.0 문제 Input Data : 비트맵 이미지의 R, G, B 값 화면 입력 : 불러올 이미지 파일 이름, 적용 필터 Output 화면 출력 : 필터 적용에 걸린 시간, 저장된 파일 이름 파일 출력 : 필터가 적용된 이미지 소스코드 : CUDA를 이용해서 멀티 스레드로 작동하는 Image Filter 프로그램 내용1. 전부 다 늘릴 때와 각각을 늘릴 때의 차이두 필터는 RGB에 일정 비율을 곱했다는 공통점이 있습니다. 이 중에 밝기 필터는 단순하게 모든 픽셀의 RGB값을 일정 비율만큼 더하면 되지만, 저희가 만든 필터는 채도를 올리는 방식이라서 붉은 계열 색상이라면 더 붉게 만들고, 푸른 계열 색상이라면 더 푸르게 만들어야 합니다. 2. 적용 방법RGB 값을 비교하고, 가장 많이 쓰인 색을 높이는 방식으로 필터를 구현했습니다. 3. 병렬화 부분그리드와 블록은 단순하게 설계하였습니다, 먼저 총 픽셀 수를 구하고, 블록 당 스레드 수를 지정하게 됩니다. 그리고 각 스레드는 한 픽셀 씩 맡아서 RGB값을 처리하게 됩니다. 이렇게 스레드가 한 픽셀을 맡게 되면 동기화 문제는 해결됩니다. 5. 결과 분석 (Intel i7-7700 &amp; GTX 1070 기준)각 필터 마다 CPU 시간을 GPU 시간으로 나누어서 계산한 차트입니다.평균적으로 10배 이상의 성능 향상을 보이고, 그레이 필터는 다른 필터보다 더 빠른 23배 정도의 성능향상이 있었습니다.아무래도 CPU나 GPU 둘 다 높은 성능 이라서 큰 차이가 보이지 않는 것 같습니다. 어려웠던 점무작정 큰 값만 늘리다보니 문제가 발생했습니다. 이 주변은 하늘이라서 주로 파란색 값이 크지만, 이 부분은 구름과 겹쳐서 파란색보다 녹색이 더 많았습니다. 그래서 이 픽셀만 녹색이 더 증가하는 문제가 생기게 된다는 사실을 알았습니다.이 문제를 해결하기 위해 허용 범위를 지정하였습니다. RGB 값의 차이가 일정 범위 이내라면 비슷한 값들을 한 번에 증가시켰습니다. 이렇게 증가시켰더니 이전 사진에서 구름 일부가 녹색으로 바뀌던 문제를 해결할 수 있었습니다. 배운 점이전에 OpenMP만 사용할 때에는 CPU만 사용했기 때문에 스레드가 많아야 겨우 8개 정도였지만, 이번에는 그래픽 카드를 이용했기 때문에 훨씬 많은 수의 스레드를 생성하고 제어하였습니다. 이 프로젝트에서는 사진 파일이 가진 픽셀 수 만큼 스레드를 생성하였는데, 1024 X 1024의 사이즈를 가진 사진이라면 100만개 이상의 스레드를 생성하게 됩니다. 너무 많은 수의 스레드를 생성하다보니 이를 제어하는 것이 처음에는 어려웠지만, 점점 익숙해져서 잘 다룰 수 있게 되었습니다.","link":"/2018/06/21/P-CUDA/"},{"title":"(개인 프로젝트) Python을 이용한 팩맨 프로젝트 중 Search와 Multiagent Search 구현","text":"소개 인원 : 1인 담당 : 프로그램 구현 전체 개발 환경 : Python 2.7 문제 : CS188 소스코드 : Python을 이용한 팩맨 프로젝트 중 Search와 Multiagent Search 구현 내용1. Search위에 보이는 것처럼 미로에서 팩맨이 어떻게 하면 최단거리로 먹이를 찾을 수 있을 지에 대한 것을 구현한 것입니다. 이를 구현하기 위해서 DFS, BFS, UCS, A* 알고리즘을 사용하였고, 각 알고리즘을 서로 비교해보았습니다. 2. Multiagent Search위에 보이는 것처럼 팩맨은 유령을 피하면서 먹이를 먹는 여러 대상을 고려한 알고리즘을 구현하였습니다. 이를 구현하기 위해서 minimax, Alpha-Beta Pruning, Expectimax 를 사용하였습니다. 어려웠던 점인공지능을 공부하면서 파이썬을 처음으로 접하게 되었는데, 평소에 사용하던 언어와 다르게 스크립트 기반의 언어라서 어색했습니다. 그래도 이 프로젝트를 진행한 덕분에 파이썬을 더욱 잘 다룰 수 있게 되었습니다. 배운 점이론적으로만 알고 있던 알고리즘들을 직접 구현해보니 상황에 따라 어떤 알고리즘을 사용해야하는 지 장단점을 직접 볼 수 있어서 도움이 많이 되었습니다. 이전에 알고리즘 과목을 수강했을 때에는 단일 대상으로부터의 검색 알고리즘 만을 배웠었지만, 이번에는 여러 대상이 있을 때에도 사용 가능한 검색 알고리즘을 익히게 되어서 더욱 다양한 환경에도 적용할 수 있게 되었습니다.","link":"/2018/05/27/P-CS188/"},{"title":"(개인 프로젝트) 식사하는 철학자들-Semaphore를 이용한 모니터와 비대칭 해결안을 적용","text":"소개 인원 : 1인 담당 : 프로그램 구현 전체 개발 환경 : Visual Studio 2015 문제 테이블에 5명의 철학자가 있고, 그 사이에 포크가 1개씩 있다. 자신에게 가장 가까이 있는 두 개의 포크만 사용할 수 있다. 식사를 하기 위해서는 무조건 두 개의 포크가 필요하고, 한 개의 포크로는 식사를 할 수 없다. 이미 다른 사람이 포크를 쥐고 있다면 그 포크를 테이블에 내려놓기 전까지 가져갈 수 없다. 철학자는 식사, 생각, 대기라는 세 가지 상태만 존재한다. (대기 = 배고픈 상태이나 포크가 부족해서 기다림) 철학자는 서로 대화할 수 없으며 포크를 들고 내려놓는 행동을 보는 것으로 상태를 확인해야 한다. 위와 같은 조건에서 아무도 굶어죽지 않도록 하는 방법을 생각하자. 소스코드 : 식사하는 철학자들-Semaphore를 이용한 모니터와 비대칭 해결안을 적용 내용비대칭 해결안 기본 원리 홀수 번호의 철학자는 먼저 왼쪽 포크를 집고, 다음에 오른쪽 포크를 집는다. 짝수 번호의 철학자는 먼저 오른쪽 포크를 집고, 다음에 왼쪽 포크를 집는다. pseudocode 1234567891011121314151617main() { while (TRUE) { /* Hungry Area */ if (P % 2) { // 짝수 번호의 철학자이면 왼쪽 포크부터 wait(Left_Fork); wait(Right_Fork); } else { wait(Right_Fork); wait(Left_Fork); } /* Eat Area */ signal(Left_Fork); signal(Right_Fork); /* Think Area */ }} 해결 원리이 방법대로 철학자들이 포크를 집는다면 모든 철학자들이 한 포크만을 집는 사태는 벌어지지 않습니다. 양 옆의 철학자가 서로 같은 포크를 집으려하기 때문에 그 포크를 먼저 집는 사람이 다음 에 식사를 하게 됩니다. 실행화면 어려웠던 점가장 어려웠던 점은 windows의 환경에 맞게 프로젝트를 설정하는 일이었습니다. 인터넷 검색을 통해서 pthread와 semaphore의 사용법을 검색해보았지만 Linux의 gcc 환경에서 사용하라는 글이 대부분이었습니다. 그래서 열심히 찾아본 결과 semaphore는 windows.h에 포함된 함수로 사용이 가능해서 매크로를 이용해 함수이름을 변환하였습니다. 하지만 pthread는 방법을 찾지 못해서 어떤 사람이 Windows에 사용 가능하도록 만들어둔 pthread.h를 직접 추가하고, 이에 필요한 lib 파일과 dll 파일을 프로젝트 경로에 추가하였습니다. 배운 점식사하는 철학자들 문제에 대한 여러 가지 해결책을 생각해보았습니다. 모두가 일정한 간격으로 식사하고 생각한다면 타이머를 이용해서 간단하게 해결이 가능하지만, 꼭 그렇지는 않다는 것이 이 문제의 중점이라 생각했습니다. 그래서 가장 보편적인 해결안인 비대칭 해결안을 사용하게 되었고, lock과 unlock을 위해서는 semaphore를 사용하였습니다. 프로그래머가 semaphore를 사용할 때 오류가 발생하지 않도록 주의하며 프로그래밍을 해야 하는 단점이 있지만, 여기서는 추상화된 데이터 형인 모니터를 이용했기 때문에 안전하게 프로그래밍을 할 수 있었습니다. 또한 미리 정의된 함수들을 이용한 덕에 소스코드도 짧게 작성할 수 있었습니다.","link":"/2017/05/18/P-Dining/"},{"title":"(개인 프로젝트) 파일 전송 서버와 클라이언트 제작","text":"소개 인원 : 1인 담당 : 프로그램 구현 전체 개발 환경 : Ubuntu 16.04 LTS, VMware Workstation 14 Player 문제 파일 전송 서버는 서버에서 실행중이며 클라이언트가 전달해주는 내용을 파일로 저장하고 보내주는 역할을 한다. 파일 전송 클라이언트는 서버에 전송할 파일을 선택하여 전송하고, 서버에서 선택한 파일을 전송받아 저장하는 기능을 수행한다. (get : 다운로드 명령, put : 업로드 명령) 클라이언트는 접속한 디렉토리에 대해서 파일을 업로드, 다운로드 하도록 함. 서버에 전송한 파일을 저장하는 디렉토리는 서버 프로세스가 실행되는 곳으로 함. 다운로드할 수 있는 파일은 전체 디렉토리를 대상으로 가능함. (퍼미션을 고려하여 다운로드 가능한 파일) text 파일, binary 파일 모두 전송이 가능하도록 함. 소스코드 : Linux에 C로 FTP Server와 Client 작성하기 사용법 : Linux에 C로 FTP Server와 Client 작성하기 내용컴퓨터의 수가 부족하여 부득이하게 로컬에서 서버와 클라이언트를 함께 실행하였습니다. 이 중에 위에 있는 터미널은 서버, 아래에 있는 터미널은 클라이언트 입니다.클라이언트는 6가지의 명령을 사용할 수 있습니다. get : 서버에서 파일 다운로드 put : 서버로 파일 업로드 pwd : 현재 디렉토리 위치 ls : 현재 디렉토리의 파일 목록 cd : 디렉토리 이동 quit : 접속 해제 어려웠던 점평소에는 터미널에서 고작 문자나 주고받는 소켓프로그래밍을 하였지만, 이번에 파일을 통째로 전송해야해서 처음에 어떻게 구현을 해야할지 막막했습니다. 그래서 다른 사람의 소스코드를 참고해가면서, 파일 사이즈를 먼저 전송하고 그 이후에 파일을 전송하는 방식으로 문제를 해결했습니다. 배운 점TCP 부분을 응용해서 구현해야하는 프로젝트였습니다. 처음에는 이 문제를 어떻게 해결해야 할지 고민이 많았지만 하나씩 차근차근 해결해나가다 보니 프로그램이 완성되어 있는 것을 볼 수 있었습니다.기본적인 기능 구현 이외에 사용자 편의성을 높이기 위해서 더욱 직관적인 사용법을 도입하였고, 색을 통한 구분으로 가독성이 뛰어나도록 더욱 깔끔한 출력을 하기 위해서 많은 시간을 투자하였습니다. 이를 통해 사용자는 보다 편리한 사용이 가능하고, 손쉽게 파일을 주고받을 수 있습니다.이렇게 사용자를 배려한 프로그램을 구현하다보니 평소에 습득하지 못했던 지식을 더욱 알아갈 수 있는 계기가 되었고, 실력향상에 많은 도움이 되었던 것 같습니다.","link":"/2018/06/03/P-FTP/"},{"title":"(개인 프로젝트) Java로 만든 채팅 프로그램 - IntraMessenger","text":"소개 인원 : 1인 담당 : 프로그램 구현 전체 개발 환경 : JDK 8 소스코드 : Java로 만든 채팅 프로그램 - IntraMessenger 내용부대에서 사용하기 위해 개발했던 것으로 지금은 DB가 없어서 작동하지 않으며, 스크린샷도 존재하지 않습니다. 작동 방식 로그인 기능 구현 : ID와 PW를 DB에서 동시에 검색하여 나온 필드가 존재한다면 로그인이 됩니다. 실시간 채팅 구현 : 채팅창이 활성화 되어있는 동안에는 스레드를 생성하여 새로 도착한 메시지가 있는지 계속 확인합니다. 단점 및 취약점 DB를 제외하고 별도의 서버가 존재하지 않아서 DB접속을 위한 ID와 PW가 클라이언트에 노출되어 있음 실시간 채팅을 위해서 DB에 로그인하고 쿼리를 보내 계속 확인 작업을 해야하므로 DB에 큰 무리가 있음 어려웠던 점개발 당시에 Java를 처음 공부했던 시절이라 코드를 비효율적으로 작성해서 유지보수가 어려웠습니다. DB와 Java를 연동해보는 일도 처음이어서 개발하는 컴퓨터로는 프로그램이 작동하는데, 사용자의 컴퓨터로는 Oracle 드라이버가 로딩되지 않아서 프로그램이 작동하지 않는 오류도 있었습니다. 사소한 부분에 오류가 있었고, 부대에서는 정보검색에 한계가 있어서 이 부분을 해결하는 일이 어려웠습니다. 배운 점일과시간에 항상 이 프로그램을 만들 수는 없기 때문에 저녁에 손으로 코드를 작성하고, 일과시간에는 전날 저녁에 작성한 코드를 입력하는 방식으로 프로그램을 천천히 완성하였습니다. 손으로 코드를 작성하는 일을 많이 하다보니 눈으로 디버깅하는 능력이 좋아져서 컴퓨터로 옮기더라도 오류가 거의 나지 않고 잘 작동하였습니다. 그래서 평소에 소스코드를 눈으로 보더라도 어디가 잘못된 곳인지 찾아내는 능력이 많이 향상되었습니다.","link":"/2014/11/01/P-IntraMessenger/"},{"title":"(개인 프로젝트) OpenMP를 이용하여 멀티 스레드로 작동하는 정렬 및 검색 프로그램","text":"소개 인원 : 1인 담당 : 프로그램 구현 전체 개발 환경 : Visual Studio 2015, OpenMP 2.0 문제 Input Data : 0~RANGE 범위, 1,073,741,824개의 floating point number 화면 입력 : 2개의 정수 값 – 예) 4 9 Output 화면 출력 : Sorting에 걸린 시간, Search에 걸린 시간 파일 출력 : 정렬한 리스트, 검색한 숫자의 개수와 리스트 소스코드 : OpenMP를 이용하여 멀티 스레드로 작동하는 정렬 및 검색 프로그램 내용1. 일상에서의 접근문제를 먼저 우리 주변에 있을 수 있는 일로 가져와서 생각해보려고 합니다. 만약 1부터 100까지 숫자가 적힌 카드가 왼쪽처럼 섞여 있을 때, 오름차순으로 정리하려면, 방법은 크게 두 가지 정도 있을 거라고 생각합니다. 하나씩 숫자를 확인하면서 정리된 카드와 비교하고 정리하는 방법과 110, 1120…으로 미리 분류하고 각각 정리하는 방법입니다. 아마도 카드의 개수가 적으면 방법1이 더 빠르겠지만 일정 개수를 넘어간다면 방법2가 더 빠를 것이라고 생각합니다. 2. 실제 문제에 적용가장 큰 숫자의 크기만큼 배열을 만들어서 이렇게 분류하고, 각 배열을 정렬하는 방법을 생각했습니다. 이 방법을 적용하기 위해서 미리 랜덤 숫자들의 분포를 세서 0번째는 17개, 1번째는 6개….이런 식으로 동적 할당을 해야 합니다. 이렇게 하면 랜덤 수를 저장할 배열 4GB와 숫자를 정리할 배열 4GB로 총 8GB가 필요하고, 메모리 16GB정도의 컴퓨터라면 충분히 실행할 수 있습니다. 3. 병렬화 부분각 배열을 정렬하는 부분을 병렬로 처리하였습니다. 만약 정렬을 하는 알고리즘을 병렬화 한다면 스레드 사이에 동기화가 필요해서 성능에 좋지 않은 영향을 줄 수 있지만, 이 방법은 각 배열을 정렬하기 때문에 동기화가 전혀 필요하지 않아서 각 스레드가 제 성능을 온전히 발휘할 수 있습니다. 4. 검색 알고리즘정렬할 때 정수 인덱스를 기준으로 정렬하였고, 각 배열의 크기를 알고 있기 때문에 정수 범위로 검색된 데이터는 단순하게 출력만 하면 됩니다. 따라서 바로 출력만 하면 되기 때문에 시간 복잡도는 O(1)입니다. 5. 결과 분석 (Intel i7-6700K @ 4.00GHz &amp; 16GB RAM 기준)시리얼 시간을 병렬 시간으로 나누어서 계산한 차트입니다.스레드가 2개일 때는 약 1.8배, 4개일 때는 2.99배, 8개일 때는 4.09배 정도 성능이 향상되었습니다. 아무래도 물리적인 코어 수는 4개라서 스레드를 8개를 사용하면 효율이 떨어지게 되는 것 같습니다. 그리고 4개를 사용할 때에는 이 프로그램 뿐 만 아니라 다른 백그라운드 프로그램도 프로세서를 사용해야 하기 때문에 2개를 사용했을 때 보다 효율이 떨어질 수밖에 없습니다. 어려웠던 점처음 구현할 때는 벡터나 리스트를 이용해서 구현하려고 했지만 숫자가 너무 많아서 컴퓨터의 메모리 용량을 초과하는 문제가 발생했습니다. 이에 따라 최적화를 진행하게 되었고, 한 번 파일을 모두 읽은 뒤에 동적할당을 함으로써 이 문제를 해결하였습니다. 배운 점4학년이 되기 전까지 모든 프로젝트는 싱글코어를 활용한 프로그램들이었지만, 이번에 OpenMP를 배우게 되어 처음으로 멀티코어를 활용한 프로그램을 만들게 되었습니다. 정렬은 정렬할 개수가 많을 수록 오랜 시간이 소요되는 작업인데, 멀티코어를 활용하여 프로그램을 제작하니 빠른 속도로 결과를 얻을 수 있었습니다. 또한, 항상 빠른 정렬 알고리즘을 사용한다고 해서 병렬 처리를 할 때 더 좋은 결과를 얻는 것은 아니라는 사실도 깨달았습니다.","link":"/2018/05/03/P-OpenMP/"},{"title":"(팀 프로젝트) 특수한 스킬을 가진 쥐로 미로의 출구 찾기","text":"소개 인원 : 4인 담당 : 팀장 및 프로그램 구현 팀원 : 팀원1 - 미로 작성, 팀원2 - 보고서 작성, 팀원3 - PPT작성 개발 환경 : Visual Studio 2015 문제 미로는 .txt파일로 입력된다. 미로의 모양은 사각형이긴 하지만 크기는 임의의 으로 미리 그 크기를 알 순 없고, 미로 내에 있는 1개의 출구의 위치 또한 미리 알 수 없다. 단, 미로의 입구는 (0, 1)이다 미로에서 출구를 찾는 쥐는 최초에 의 에너지와 0의 마나를 지닌다. 쥐는 미로의 상하좌우만 움직일 수 있고, 사선으로 움직일 수 없다. 쥐는 미로를 한 칸 움직일 때마다 에너지를 1 소모하게 되며, 마나를 1 획득하게 된다. 쥐는 10의 마나를 소모해서 임의의 만큼 미로를 스캔할 수 있고, 30의 마나를 소모해서 벽 한 칸을 뚫을 수 있다. 단, 외벽은 파괴할 수 없다. 소스코드 : 특수한 스킬을 가진 쥐로 미로의 출구 찾기 내용알고리즘 설계 탐욕적 알고리즘을 적용한다.(현재 위치로부터 가상의 목적지까지 가장 거리가 짧은 방향으로 이동한다.) 쥐는 지금까지의 이동경로를 모두 기억하고 있다. 쥐가 스캔을 통해 목적지를 찾았을 경우, 목적지 주변 일정한 부분을 스캔으로 탐색합니다. 쥐는 막다른 길에 도달했거나 스캔을 통해 목적지를 찾았을 경우, 자신이 기억하고 있는 경로를 통해 목적지로 향하는 최단(최적)경로를 찾아간다. 목적지를 스캔을 통해 찾았을 경우, 그 주변으로 스캔 범위를 넓혀간다. 현재 쥐의 위치부터 목적지까지의 경로 중, 스캔을 통해 찾아낸 경로나 쥐가 이동을 통해 찾아낸 가장 짧은 경로로 이동한다. 마나가 30이상이며 스캔을 통해 출구를 찾았으며, 최적의 경로로 출구를 향해 이동중일 때 벽을 만났는데 마나가 4 이상인 경우, 진행방향으로 스캔을 뿌려보고 벽이 1칸 있으면 그 벽을 뚫고 지나간다. 어려웠던 점일반적인 미로찾기가 아니라 마나와 스킬을 가진 미로찾기여서 어떻게 알고리즘을 구현하는 것이 효율적일지 생각하는 것이 가장 어려웠습니다. 그래서 평균적으로 확률을 높이는 것이 가장 좋은 방법이라고 생각해서 위와 같은 알고리즘으로 구현하게 되었습니다. 배운 점평소에는 콘솔 기반의 프로그램을 위주로 만들었지만, 이번에는 GUI를 이용해서 프로그램을 만들었습니다. 그렇다보니 그림의 배치나 색 등 여러가지 고려할 부분이 늘어나서 처음에는 생각보다 잘 안되었지만, 이런 부분을 해결해나가는 과정에서 자료 검색 능력이나 문제를 해결하는 센스가 더욱 늘어났습니다.","link":"/2017/06/05/P-Maze/"},{"title":"(개인 프로젝트) PHP기반 반응형 피아노 동아리 홈페이지 제작","text":"소개 인원 : 1인 담당 : 프로그램 구현 전체 개발 환경 : PHP 5.2.12, MySQL, bootstrap 소스코드 : PHP기반 반응형 피아노 동아리 홈페이지 제작 내용주요기능 어려웠던 점게시판을 DB와 연동해서 구현하는 것이 가장 어려웠습니다. HTML이나 CSS 같은 프론트엔드 부분을 위주로 다뤄본 탓에 백엔드 부분에는 서툰 면이 있었습니다. 그래서 인터넷을 참고해가면서 페이지 넘김이나 검색 부분을 구현했습니다. 배운 점실제로 피아노 동아리 활동을 하고 있는데, 이 홈페이지를 만들면서 다른 동아리원들의 의견도 반영하였습니다. 동아리 일정 기록을 위한 달력 제작도 부탁받았지만, 아직 실력이 부족해서 구현할 수 없었습니다. 이처럼 실제 사용자의 의견을 들으면서 홈페이지를 만들어 가다보니 더욱 완성도 높은 홈페이지가 제작되었습니다.","link":"/2017/12/05/P-Pianolove/"},{"title":"(개인 프로젝트) 클라이언트를 관리하는 서버 프로그램 작성","text":"소개 인원 : 1인 담당 : 프로그램 구현 전체 개발 환경 : Ubuntu 16.04 LTS, VMware Workstation 14 Player 문제 클라이언트 간의 채팅 프로그램을 기반으로 작성한다. 서버는 접속하는 클라이언트가 송신한 메시지를 모두 관리하고 모니터링 한다. 클라이언트가 보내는 문자를 모두 기록하고 있으며, 총 문자 수, 보낸 시간 등의 내역을 보관한다. 이 외에 서버는 총 접속자 수(클라이언트의 총 접속자 수), 각 클라이언트의 접속 시간, 클라이언트의 IP를 관리한다. 클라이언트는 최소 5개 이상 접속이 되도록 작성하시오. 소스코드 : Linux에서 Socket으로 채팅구현하기 사용법 : Linux에서 Socket으로 채팅구현하기 내용컴퓨터의 수가 부족하여 부득이하게 로컬에서 다중 클라이언트를 실행하였습니다. 이 중에 가장 오른 쪽 위에 있는 터미널이 서버 역할을 하고 있습니다.서버에서는 클라이언트가 보내는 메시지를 모두 확인할 수 있습니다. 위 터미널은 서버가 처음 실행되었을 때 나오는 화면이고, 서버는 4가지의 명령어를 사용할 수 있습니다. help : 도움말 출력 num_user : 현재 접속한 유저의 수 num_chat : 현재까지 오간 대화의 수 ip_list : 현재 접속한 유저들의 IP 어려웠던 점이 문제를 해결하면서 어려웠던 점은 기능 구현보다 터미널의 글씨에 색상을 입히는 작업이었습니다. 일반적인 printf로는 잘 작동하지 않았고, write나 fprintf(stderr)을 이용해서 해결하였습니다. 배운 점이번 프로젝트는 사용자 편의성을 높이는 데에 더욱 집중하였고, 더욱 깔끔한 출력을 하기 위해서 많은 시간을 투자하였습니다. 그러다보니 평소에 습득하지 못했던 지식을 더욱 알아갈 수 있는 계기가 되었고, 실력향상에 많은 도움이 되었습니다.","link":"/2018/05/18/P-Socket/"},{"title":"파티셔닝","text":"파티셔닝개념테이블을 파티션이라는 작은 단위로 나누어 관리하는 기법 종류 수평 파티셔닝 개념 샤딩과 동일한 개념 스키마를 복제한 후 샤드키를 기준으로 데이터를 나누는 것을 말한다. 즉, 스키마가 같은 데이터를 두 개 이상의 테이블에 나누어 저장하는 것을 말한다. 장점 데이터의 개수를 기준으로 나누기 때문에 데이터의 개수가 작아지고, 따라서 인덱스의 개수도 작아진다. 그러므로 자연스럽게 성능은 향상된다. 단점 데이터를 찾는 과정이 기존보다 복잡하기 때문에 latency가 증가한다. 하나의 서버가 고장나게 되면 데이터의 무결성이 깨질 수 있다. 수직 파티셔닝 개념 테이블의 컬럼을 기준으로 나누는 것을 말한다. 정규화하는 것과 비슷하지만 이미 정규화된 데이터를 분리하는 과정이다. 장점 자주 사용하는 컬럼을 분리하여 성능을 향상할 수 있다. 분할 기준 범위 분할(Range Partitioning) 연속적인 숫자나 날짜를 기준으로 분할한다. 우편번호, 일별, 월별, 분기별 등의 데이터에 적합하다. 목록 분할(List Partitioning) 특정 파티션에 저장될 데이터에 대한 명시적 제어가 가능하다. 분포도가 비슷하며, 많은 SQL에서 해당 컬럽의 조건이 많이 들어오는 경우 유용하다. [한국, 일본, 중국 -&gt; 아시아][노르웨이, 스웨덴, 핀란드 -&gt; 북유럽] 등의 예시가 존재한다. 해시 분할(Hash Partitioning) 해시 함수의 값에 따라 어떤 파티션에 포함할지 여부를 결정한다. 파티션을 위한 범위가 없는 데이터에 적합하다. 합성 분할(Composite Partitioning) 위의 기술을 결합하여 사용하는 방법을 말한다. 범위 분할을 할 수 있지만, 분할된 결과가 너무 커서 효과적으로 관리할 수 없는 경우에 유용하다. 범위-목록, 범위-해시 등의 예시가 존재한다. 참조 https://nesoy.github.io/articles/2018-02/Database-Partitioning https://gmlwjd9405.github.io/2018/09/24/db-partitioning.html","link":"/2019/02/24/Partitioning/"},{"title":"Redis 설치","text":"Redis 서버Redis 설치 및 실행12345678910111213141516171819202122232425[~]$ wget http://download.redis.io/redis-stable.tar.gz[~]$ tar xvzf redis-stable.tar.gz[~]$ cd redis-stable/src[~]$ vim MakefilePREFIX?=~/apps/redis-server &lt;- 이부분 수정[~ src]$ mkdir ~/apps/redis-server[~ src]$ make PREFIX=~/apps/[~ src]$ make test[~ src]$ make install[~ src]$ cd ~/apps/redis-server[~ redis-server]$ mkdir conf[~ redis-server]$ cp ~/redis-stable/redis.conf ./conf/[~ redis-server]$ vim conf/redis.conf bind x.x.x.x &lt;- 이 부분을 현재 서버 IP로 설정daemonize yes &lt;- 이 부분 no를 yes로 수정 [~ redis-server]$ ./bin/redis-server ./conf/redis.conf[~ redis-server]$ ps -ef | grep redis - 0000 1 0 00:00 ? 00:00:00 ./bin/redis-server conf/redis.conf x.x.x.x:6379- 0000 00000 0 00:00 pts/0 00:00:00 grep redis 실행 스크립트123456#!/bin/bashREDIS_DIR=~/apps/redis-server #### Main ###### apps/redis-server/bin/redis-server apps/redis-server/conf/redis.conf$REDIS_DIR/bin/redis-server $REDIS_DIR/conf/redis.conf Springpom.xml123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;biz.paluch.redis&lt;/groupId&gt; &lt;artifactId&gt;lettuce&lt;/artifactId&gt; &lt;version&gt;4.5.0.Final&lt;/version&gt;&lt;/dependency&gt; application.properties12345spring.redis.lettuce.pool.max-active=10spring.redis.lettuce.pool.max-idle=10spring.redis.lettuce.pool.min-idle=2spring.redis.port=6379spring.redis.host=x.x.x.x RedisConfiquration.java12345678910111213141516@Configuration public class RedisConfiguration { @Bean public RedisConnectionFactory redisConnectionFactory() { return new LettuceConnectionFactory(&quot;x.x.x.x&quot;, 6379); } @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate() { RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionFactory()); redisTemplate.setKeySerializer(new StringRedisSerializer()); return redisTemplate; }} RedisServiceTest.java123456789101112131415@RunWith(SpringRunner.class)@SpringBootTestpublic class RedisServiceTest { @Autowired RedisTemplate&lt;String, Object&gt; redisTemplate; @Test public void test() { ValueOperations&lt;String, Object&gt; vop = redisTemplate.opsForValue(); vop.set(&quot;test1&quot;, &quot;햇님&quot;); assertEquals(&quot;햇님&quot;,vop.get(&quot;test1&quot;)); }}","link":"/2019/02/09/Redis/"},{"title":"당신의 게임은 안전한가요?","text":"시큐어 코딩과 관련해서 경험한 이야기가 있습니다.잡지에 있는 하나의 글처럼 가볍게 읽어주시면 감사하겠습니다. 취미로 아주 작은 게임 서버를 운영하는 친구가 있습니다.친구는 자신이 만든 게임을 플레이해보라고 제안했습니다.그런데 저는 친구의 의도대로 순순히 게임을 즐길 생각이 없었습니다. 사건의 시작단기간에 강해지길 원했습니다.노가다없이 게임 내 재화를 많이 얻고 싶었고, 가장 초보적인 방법인 메모리 변조를 해보기로 했습니다.이 공격을 위해 만들어진 도구인 치트엔진을 사용해서 첫 공격을 시도했습니다. 골드를 늘리기 위해 현재 가진 골드(71497)를 입력하고 스캔했습니다.그런데 동일한 값을 가진 항목이 여러 개 검색되어 어떤 게 골드인지 특정할 수 없었습니다.골드를 의미하는 주소를 정확히 찾기 위해 골드를 2만큼 더 얻어서 71499로 만든 후 다시 스캔해봤습니다. 이것을 반복하다가 결국 하나가 남게 되면 정확한 값을 찾는 데 성공한 것입니다.찾은 값은 마음대로 변경할 수 있었고, 변경된 값이 게임 내에도 잘 반영되었습니다. 이 방법으로 스탯, 경험치, 아이템, 골드 등 모든 것을 복사하거나 얻었고, 이것을 알게 된 친구의 표정은 어두워졌습니다. 어떻게 이런 게 가능했을까요?친구가 만든 게임 서버는 클라이언트를 100% 신뢰하고 있었고, 대부분의 로직이 클라이언트에 있었습니다.그리고 클라이언트가 보낸 데이터를 아무런 의심 없이 게임 서버 DB에 저장해버렸죠. 게임에 필요한 모든 것을 얻었지만 여기서 멈추지 않았습니다.값 하나를 바꾸기 위해 매번 이 작업을 하기에는 너무나 번거로웠습니다.어떻게 하면 더 쉽게 재화를 얻을 수 있을까 고민하다가 서버와 클라이언트 사이에 오가는 값을 조작해보기로 했습니다. 본격적인 조작값을 조작하기에 앞서 어떤 패킷들이 오가는지 확인하고 싶었습니다.패킷 분석 도구로 와이어샤크라는 유명한 도구가 있습니다.이 도구로 모니터링을 시작한 채 게임에 접속하자마자 패킷이 쏟아지기 시작했습니다.사냥터에 들어가 보니 이런 내용을 가진 패킷도 보입니다. 12&lt;mon_move&gt;177,6,4,6,11&lt;/mon_move&gt;&lt;!-- 대략 몬스터가 움직인다는 뜻 --&gt; 패킷은 전혀 암호화되어있지 않았고, 그때 저는 이런 생각이 들었습니다. 바로 실행에 옮겼습니다. 게임에 로그인된 상태이니 바로 데이터를 전송해보기로 했습니다. 12345ip: 192.168.0.1port: 12501content: &lt;str&gt;9000&lt;/str&gt;&lt;!-- IP가 192.168.0.1이고, 포트 번호가 12501인 곳에 힘 스텟 9000을 보냄 --&gt;&lt;!-- 실제 패킷은 완전히 다르게 생겼습니다. --&gt; 와이어샤크에서 패킷을 추출한 후 일반적인 에디터로 위와 같이 변경했고, bittwist를 사용해서 패킷을 전송해봤습니다. 1234567$ bittwist -v -i eth0 test.pcapsending packets through eth0trace file: test.pcap2 packets (2218 bytes) sentElapsed time = 0.021880 seconds# 서버로 패킷을 보내는 데에 성공 패킷이 성공적으로 전송되었습니다. 패킷 전송 별거 아니군! 많은 기대를 하면서 게임에 접속해봤습니다. 하지만…기대와는 다르게 전혀 바뀐 게 없었습니다. 실패의 연속왜 그랬을까? 한참 생각해보다가 이건 HTTP가 아니라 TCP 소켓 연결이라는 것을 알았습니다.게임에 처음 접속하면 연결을 맺고, 게임을 하는 동안에는 그 연결을 유지한 채로 데이터를 주고받았습니다.이미 클라이언트와 서버가 서로 연결되어있을 때, 그 중간에 패킷을 넣어 보내는 것은 어렵습니다. 새로운 도전을 하기로 했습니다. 이 방법은 중간자 공격이라고도 불립니다.클라이언트와 서버 사이에 프록시 서버를 두고, 클라이언트와 서버가 통신할 때 이를 조작해서 전송할 수 있습니다. 이 작업을 쉽게 할 수 있는 도구로 Burp Suite가 있으며 이 도구는 HTTP 통신 시 값을 가로채서 조작하는 것에 자주 사용됩니다.이것만으로는 TCP 소켓 통신을 가로챌 수 없어서 NoPE Proxy확장 프로그램도 함께 설치했습니다.여러 글을 참고해서 이것저것 설정하고 나서 패킷이 잘 들어오나 확인해보았지만, 전혀 반응이 없었습니다. 관련된 글을 더 찾아보니 NoPE Proxy는 DNS를 이용하는 방식이라서 서버에 도메인이 있어야 합니다.친구의 서버는 IP만 있고, 도메인이 없어서 이 도구를 사용하는 데에 어려움이 있었습니다.여기에 더 시간을 쏟는 것보다 다른 방법을 찾는 게 빠를 것 같아서 한참을 만지작대다가 포기했습니다. 새로운 마음가짐적절한 도구가 더 없을까 찾아보다가 결국 직접 만들기로 했습니다. (저는 개발자니까요!) 학창 시절에 TCP 소켓으로 채팅 프로그램을 만들었던 기억을 떠올려서 차근차근 만들었고, 직접 서버에 연결해봤습니다. 12$ ./client 192.168.0.1 12501 # 예시 IP, port 입니다.Connection Success 서버와 연결하는 데에 성공했습니다!이제 로그인을 하고 나서 스탯 조작을 위한 명령어를 서버에 보내면 됩니다. 123client: &lt;str&gt;9000&lt;/str&gt;server: &lt;str&gt;success&lt;/str&gt;&lt;!-- 대략 힘 스탯을 9000으로 만들었다는 뜻 --&gt; 이전에 와이어샤크로 수집한 패킷을 똑같이 보내보니 서버에서 정상적으로 응답이 왔습니다.다른 스탯도 모두 9000으로 만들어서 보내봤습니다. 성공적입니다!! 이제 게임의 모든 걸 조작할 수 있습니다.보스를 한 방에 없앨 수도 있고, 운영자 전용 아이템을 얻을 수도 있습니다. 친구는 이 상황을 실시간으로 보고 있었습니다.입에 거품을 물고 있습니다. 여기서 멈출 수 없지호기심은 여기서 끝나지 않았습니다. 다른 유저의 데이터도 변경해보고 싶었습니다.앞에서는 데이터 조작을 간단하게 소개했지만, 사실 아래와 같은 순서로 이루어집니다. 서버 연결 &gt; 로그인 &gt; 데이터 로드 &gt; 조작 일반적으로 A 유저로 로그인을 하면 A 유저의 데이터만 가져올 수 있는데,A 유저로 로그인하고 나서, B 유저의 데이터를 가져오는 게 가능할지 궁금했습니다. 123456client: &lt;login&gt;userA&lt;/login&gt;server: &lt;login&gt;success&lt;/login&gt;&lt;!-- A 유저로 로그인하고 나서 B 유저의 데이터 로딩 시도 --&gt;client: &lt;dataload&gt;userB&lt;/dataload&gt;server: &lt;dataload&gt;success&lt;/dataload&gt;&lt;!-- B 유저 로딩 성공 --&gt; 이제 저는 다른 유저의 데이터도 조작할 수 있습니다.마음에 드는 유저에게 아이템을 주거나 저를 방해하는 유저의 모든 스탯을 1로 만들어버릴 수도 있습니다. 요약 친구가 아주 작은 게임 서버를 운영한다. 필자는 강해지고 싶었다. 필자는 클라이언트 메모리 변조로 모든 것을 얻었다. 친구의 표정은 어두워졌다. 클라이언트와 서버 사이의 패킷을 훔쳐보고 위조했다. 친구는 입에 거품을 물었다. 다른 유저 데이터까지 변경해버렸다. 친구는 쓰러졌다. 이를 통해 얻은 것 서버는 클라이언트가 보낸 정보를 무조건 신뢰하면 안 된다. 중요한 정보는 암호화하여 위변조가 어렵게 해야 한다.","link":"/2021/12/26/S-GameSecure/"},{"title":"The Context Container","text":"원문https://tomcat.apache.org/tomcat-8.5-doc/config/context.html#Context_Parameters 소개기본 디렉토리로 $CATALINA_BASE 의 상대 경로를 사용하고, 설정하지 않은 경우에는 $CATALINA_HOME으로 설정됩니다. 컨텍스트 경로는 가장 긴 Request URI 부터 매칭됩니다. 속성 allowCasualMultipartParsing대상 서블릿이 @MultipartConfig 어노테이션으로 표시되지 않은 경우에도 HttpServletRequest.getPart* 또는 HttpServletRequest.getParameter*가 호출 될 때, 톰캣이 multipart / form-data 요청 본문을 자동으로 구문 분석해야하는 경우 true로 설정합니다. false가 아닌 다른 설정은 톰캣이 기술적으로 규격을 준수하지 않는 방식으로 작동하도록합니다. 기본값은 false입니다. allowMultipleLeadingForwardSlashInPath 톰캣에 여러 /를 단일 /로 정규화합니다. 이것은 URI가 파일 시스템 경로로 변환되는 것처럼 파일 시스템의 동작과 일관성을 유지하지 위함입니다. 기본값은 false이며 여러 개의 /문자를 접을 수 있습니다. altDDNamealternative deployment descriptor의 절대 경로입니다. 이는 /WEB-INF/web.xml에 있는 default deployment descriptor를 override 합니다. backgroundProcessorDelay backgroundProcess메소드를 호출할 때 까지의 지연시간을 초 단위로 나타냅니다. 기본값은 -1이고, 컨텍스트가 상위 호스트의 백그라운드 처리 스레드에 의존함을 의미합니다. className 사용할 Java클래스 이름. 이 클래스는 org.apache.catalina.Context인터페이스를 구현해야합니다. 지정하지 않으면 표준값이 사용됩니다. containerSciFilter SCI가 제공한 컨테이너의 정규식으로 이 컨텍스트에 사용하지 않도록 필터링합니다. 매칭은 java.util.regex.Matcher.find()를 사용하므로 정규 표현식은 필터링을 위해 SCI가 제공 한 컨테이너의 정규화 된 클래스 이름의 하위 문자열과 일치해야합니다. 지정하지 않으면 필터링이 적용되지 않습니다. cookies 브라우저가 쿠키를 지원해야하고, 세션 식별 통신에 쿠키를 사용하려면 true로 설정합니다. crossContext 이 응용 프로그램 내에서 ServletContext.getContext() 호출이 이 가상 호스트에서 실행중인 다른 웹 응용 프로그램의 요청 디스패처를 성공적으로 반환하도록하려면 true로 설정합니다. 보안이 있는 환경에서는 false (기본값)로 설정하여 getContext()가 항상 null을 반환하도록합니다. docBase 웹애플리케이션을 위한 문서 디렉토리나 웹애플리케이션의 아카이브 파일의 경로이름입니다. 절대경로나 appBase의 상대경로로 지정이 가능합니다. 컨텍스트 요소가 server.xml에 정의되어 있거나 docBase가 호스트의 appBase아래에 정의되어 있지 않다면 필드의 값을 설정하지 않아야 합니다. docBase에 심볼릭 링크가 사용되면 톰캣을 재시작하거나 컨텍스트를 재배포해야 적용됩니다. dispatchersUseEncodedPaths 인코딩 여부를 제어합니다. 이것은 톰캣이 요청 디스패처를 얻기 위해 호출을 처리하는 것과 내부적으로 요청 디스패처를 얻는 데 사용되는 경로를 생성하는 것에 모두 영향을 줍니다. 기본값은 true입니다. failCtxIfServletStartFails 서블릿이 load-on-startup &gt;=0인 경우 컨텍스트 시작을 실패하도록 하려면 true로 설정합니다. 지정하지 않으면 상위 호스트의 구성에서 동일한 이름의 속성이 지정된 경우 그것을 사용힙니다. 그렇지 않으면 기본값이 false가 사용됩니다. fireRequestListenersOnForwards 톰캣이 요청을 전달할 때 구성된 ServletRequestListeners를 시작하려면 true로 설정합니다. 주로 ServletRequestListeners를 사용하여 요청에 필요한 환경을 구성하는 CDI 프레임 워크 사용자에게 유용합니다. 지정하지 않으면 false의 기본값이 사용됩니다. logEffectiveWebXml 애플리케이션이 시작될 때 웹애플리케이션에 사용되는 유효한 web.xml이 (INFO 수준에서) 기록되도록하려면 true로 설정합니다. 효과적인 web.xml은 톰캣이 구성한 모든 기본값과 발견 된 web-fragment.xml 파일 및 주석을 결합한 애플리케이션의 web.xml입니다. 지정하지 않으면 false의 기본값이 사용됩니다. mapperContextRootRedirectEnabled 활성화 된 경우 웹애플리케이션 컨텍스트 루트에 대한 요청은 기본 서블릿이 아닌 매퍼가 필요에 따라 리디렉션됩니다. 이것은 효율적이지만 컨텍스트 경로가 있는지 확인하는 문제가 있습니다. 지정하지 않으면 기본값 true가 사용됩니다. mapperDirectoryRedirectEnabled 활성화 된 경우 웹애플리케이션 디렉토리에 대한 요청은 기본 서블릿이 아닌 매퍼가 필요에 따라 리디렉션됩니다. 이것은 효율적이지만 디렉토리가 있는지 확인하는 문제가 있습니다. 지정하지 않으면 기본값 false가 사용됩니다. override 전역 또는 호스트 기본 컨텍스트의 설정을 무시하려면 true로 설정합니다. 기본적으로 기본 컨텍스트의 설정이 사용되지만 컨텍스트에 대해 동일한 속성을 명시적으로 설정하여 무시할 수 있습니다. path 처리 할 적절한 웹애플리케이션을 선택하기 위해 각 request URI의 시작과 대조되는 이 웹 응용 프로그램의 컨텍스트 경로입니다. 특정 호스트 내의 모든 컨텍스트 경로는 고유해야합니다. 빈 문자열 ( “”)의 컨텍스트 경로를 지정하면이 호스트에 대한 기본 웹애플리케이션을 정의하며 다른 컨텍스트에 할당되지 않은 모든 요청을 처리합니다. 이 속성은 server.xml에서 컨텍스트를 정적으로 정의 할 때만 사용해야합니다. 다른 모든 상황에서는 경로가 .xml 컨텍스트 파일 또는 docBase에 사용 된 파일 이름에서 유추됩니다. server.xml에서 컨텍스트를 정적으로 정의하는 경우에도 이 속성은 docBase가 호스트의 appBase 아래에 있거나 deployOnStartup 과 autoDeploy가 모두 false가 아닌 경우에만 설정해야합니다. 이 규칙을 지키지 않으면 이중 배포가 발생할 수 있습니다. preemptiveAuthentication true로 설정되고 사용자가 보안 제한 조건에 의해 보호되지 않는 자원에 대한 자격을 제시하면, 인증자가 선점인증을 지원하는 경우에 사용자의 자격 증명이 처리됩니다. 지정하지 않으면 기본값 인 false가 사용됩니다. privileged 이 컨텍스트가 관리자 서블릿과 같은 컨테이너 서블릿을 사용할 수 있게 하려면 true로 설정합니다. 특별한 속성의 사용은 컨텍스트의 parent 클래스 로더를 Shared 클래스 로더 대신에 Server 클래스 로더로 변경합니다. 기본 설치에서는 Common 클래스 로더가 Server 클래스 로더와 Shared 클래스 로더 모두에 사용됩니다. reloadable 파일에 변화가 있을 때 자동으로 로딩할지 설정합니다. 기본값은 false입니다. resourceOnlyServlets 리소스가 존재하는 쉼표로 구분된 서블릿 이름의 목록입니다. sendRedirectBody true인 경우 리디렉션의 응답에 RFC2616에서 권장하는 리디렉션의 세부 정보가 포함됩니다. 응답 본문을 포함하면 압축 필터와 같은 일부 애플리케이션 구성 요소에 문제가 발생할 수 있으므로 기본적으로 사용하지 않도록 설정합니다. sessionCookieDomain 세션쿠키에 사용할 도메인입니다. sessionCookieName 세션쿠키에 사용하는 이름입니다. 설정한 경우 웹애플리케이션에서 설정한 이름을 무시합니다. sessionCookiePath 세션쿠키의 경로입니다. 설정한 경우 웹애플리케이션에서 설정한 경로를 무시합니다. sessionCookiePathUsesTrailingSlash Internet Explorer, Safari, Edge 브라우저에서 RFC6265를 위반하여 /foobar의 요청으로 /foo 경로를 가진 컨텍스트에 대한 세션 쿠키를 보내는 문제가 있습니다. 이 위험을 줄이려면 true로 설정합니다. 그러면 톰캣은 세션 쿠키와 연결된 경로에 후행 슬래시를 추가합니다. 위의 예에서 쿠키 경로는 /foo/가 됩니다. /*에 매핑 된 서블릿이 없으면 문제가되지 않습니다. 이 속성을 비활성화하려면 false로 설정합니다. 기본값은 false입니다. swallowAbortedUploads 톰캣이 중단된 업로드에 대한 추가 요청 데이터를 읽지 않고 대신 클라이언트 연결을 중단해야하는 경우 true로 설정합니다. 추가 데이터를 읽지 않으면 요청 처리 스레드가 더 빠르게 해제됩니다. swallowOutput true인 경우에 system.out과 system.err로 출력한 바이트가 웹애플리케이션의 logger로 리디렉션 됩니다. 기본값은 false입니다. tldValidation true인 경우에 TLD파일은 컨텍스트 시작시에 XML유효성을 검사합니다. org.apache.catalina.STRICT_SERVLET_COMPLIANCE가 true인 경우 디폴트 값은 true이고, 그렇지 않은 경우 디폴트 값은 false가 됩니다. true인 경우 성능에 좋지 않은 영향이 있습니다. useHttpOnly 클라이언트의 스크립트가 세션 ID에 접근하지 못하도록 합니다. 기본값은 true입니다. useRelativeRedirects HTTP 1.1 이상이고 javax.servlet.http.HttpServletResponse#sendRedirect(String)의 호출로 생성된 헤더가 절대경로나 상대경로로 리디렉션 할지 여부를 제어합니다. org.apache.catalina.STRICT_SERVLET_COMPLIANCE가 true인 경우 디폴트 값은 false이고, 그렇지 않은 경우 디폴트 값은 true가 됩니다. validateClientProvidedNewSessionId 클라이언트가 새 세션ID를 제공하면 이 속성은 해당 ID가 유효한지 여부를 제어합니다. 기본값은 true입니다. wrapperClass org.apache.catalina.Wrapper의 자바 클래스 이름입니다. 지정하지 않으면 기본값이 사용됩니다. xmlBlockExternal true인 경우에 web.xml, web-fragment.xml, *.tld, *.jspx, *.tagx and tagPlugins.xml 파일의 파싱에 외부 엔터티를 로드할 수 없습니다. 기본값은 true입니다. xmlNamespaceAware true인 경우에 web.xml, web-fragment.xml파일의 파싱이 namespace-aware가 됩니다. org.apache.catalina.STRICT_SERVLET_COMPLIANCE가 true인 경우 디폴트 값은 true이고, 그렇지 않은 경우 디폴트 값은 false가 됩니다. true인 경우 xmlValidation옵션도 true가 됩니다. xmlValidation true인 경우에 web.xml, web-fragment.xml파일의 유효성(문법)을 검사합니다. org.apache.catalina.STRICT_SERVLET_COMPLIANCE가 true인 경우 디폴트 값은 true이고, 그렇지 않은 경우 디폴트 값은 false가 됩니다. true인 경우 성능에 좋지 않은 영향이 있습니다.","link":"/2019/01/29/TheContextContainer/"},{"title":"싱글톤 주의하기","text":"문제아래의 코드를 우선 읽어보자. 해결 전 심각한 코드123456789101112131415161718192021222324252627282930313233@Controllerpublic class NoReadRecipientMailboxController { @Autowired private NoReadRecipientMailboxMapper recipientMailboxMapper; private String user_id_session; private String searchContent; private List&lt;RecipientEmail&gt; recipientEmail; private List&lt;RecipientEmail&gt; recipientStarEmail; private List&lt;RecipientEmail&gt; recipientSearchEmail; @GetMapping(&quot;/noreadreceivemailbox&quot;) public String mailbox(Model model, HttpServletRequest req) { user_id_session = (String)req.getSession().getAttribute(&quot;user_id&quot;); recipientEmail = recipientMailboxMapper.selectList(user_id_session); model.addAttribute(&quot;noreadrecipientEmail&quot;, recipientEmail); recipientStarEmail = recipientMailboxMapper.selectStarList(user_id_session); model.addAttribute(&quot;noreadrecipientStarEmail&quot;, recipientStarEmail); recipientSearchEmail = recipientMailboxMapper.searchMailTitle(searchContent, user_id_session); model.addAttribute(&quot;noreadrecipientSearchEmail&quot;, recipientSearchEmail); this.searchContent = &quot;&quot;; return &quot;mailbox/noreadreceivemailbox&quot;; } @PutMapping(&quot;/noreadreceivemailbox/searchMail/title/{searchContent}&quot;) public ResponseEntity&lt;?&gt; searchMailTitle (@PathVariable String searchContent) { this.searchContent = &quot;%&quot; + searchContent + &quot;%&quot;; return new ResponseEntity&lt;&gt;(true, HttpStatus.OK); }} 문제점 발견코드를 잘 읽어보면 처음에는 어떤 문제가 있는지 잘 모르는 경우가 많다. 하지만 이 코드는 굉장한 문제점을 가지고 있고, 이제부터 이 문제점을 해결해나가고자 한다. 1private List&lt;RecipientEmail&gt; recipientEmail; 이러한 방식으로 메소드 외부에 인스턴스 변수를 생성했을 때 스프링은 최초 동작 시에만 새롭게 생성하고, 이후에는 해당 변수를 그대로 반환한다. 그리고 싱글톤은 Thread-Safety하지 않다!여러 사용자가 동시에 이 서비스를 이용하는 경우에 다른 사용자의 값을 반환받을 경우도 생기는 것이다. 이렇게 되면 다른 사용자의 메일을 볼 수 있을지도 모른다. 아니 실제로 그런 일이 발생한다. 그러므로 아래처럼 메소드 내부에 변수를 선언하는 것이 중요하다. 해결 후 코드123456789101112131415161718192021222324252627@Controllerpublic class NoReadRecipientMailboxController { @Autowired private NoReadRecipientMailboxMapper recipientMailboxMapper; @GetMapping(&quot;/noreadreceivemailbox&quot;) public String mailbox(Model model, HttpServletRequest req, String searchContent, String view) { String user_id_session = (String)req.getSession().getAttribute(&quot;user_id&quot;); if(searchContent != null) { String Content = &quot;%&quot; + searchContent + &quot;%&quot;; List&lt;RecipientEmail&gt; recipientSearchEmail = recipientMailboxMapper.searchMailTitle(Content, user_id_session); model.addAttribute(&quot;noreadrecipientSearchEmail&quot;, recipientSearchEmail); } else if(view != null &amp;&amp; view.equals(&quot;star&quot;)){ List&lt;RecipientEmail&gt; recipientStarEmail = recipientMailboxMapper.selectStarList(user_id_session); model.addAttribute(&quot;noreadrecipientStarEmail&quot;, recipientStarEmail); } else { List&lt;RecipientEmail&gt; recipientEmail = recipientMailboxMapper.selectList(user_id_session); model.addAttribute(&quot;noreadrecipientEmail&quot;, recipientEmail); } return &quot;mailbox/noreadreceivemailbox&quot;; }}","link":"/2019/01/28/SingletonIssue/"},{"title":"&lt;algorithm&gt;","text":"sort오름차순sort(vector.begin(), vector.end()); 내림차순#include &lt;functional&gt;sort(vector.begin(), vector.end(), greater&lt;[Data Type]&gt;()); reversestd::reverse(vector.begin(), vector.end()); findstd::find(vector.begin(), vector.end(), item) != vector.end() 기본 사용법1234if ( std::find(vector.begin(), vector.end(), item) != vector.end() ) do_this(); //찾았다면else do_that(); //못 찾았다면 응용 사용법12345list&lt;int&gt;::iterator it = find(list.begin(), list.end(), item);if(it == list.end()) do_this();else list.erase(it); //it가 가리키는 노드 삭제 나머지는 필요할 때마다 추가 예정","link":"/2018/09/28/algorithm/"},{"title":"Typora","text":"이 블로그를 작성할 때에는 Markdown 언어를 사용해야 한다.Markdown 문서를 쉽게 작성할 수 있는 툴로 Typora가 있다.변환된 모양을 바로 볼 수 있어서 편리하다.","link":"/2018/05/28/Typora/"},{"title":"Linux에 C로 FTP Server와 Client 작성하기","text":"FTP Server컴파일 및 실행 방법12$ gcc -o server server.c$ ./server 9999 server.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/sendfile.h&gt;#include &lt;netinet/in.h&gt;#include &lt;fcntl.h&gt;int tcp_listen(int host, int port, int backlog) { int sd; struct sockaddr_in servaddr; sd = socket(AF_INET, SOCK_STREAM, 0); if (sd == -1) { perror(&quot;socket fail&quot;); exit(1); } // servaddr 구조체의 내용 세팅 bzero((char *)&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(host); servaddr.sin_port = htons(port); if (bind(sd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) { perror(&quot;bind fail&quot;); exit(1); } // 클라이언트로부터 연결요청을 기다림 listen(sd, backlog); return sd;}int main(int argc, char *argv[]){ struct sockaddr_in server, client; struct stat obj; int sock1, sock2; char buf[100], command[5], filename[20]; int k, i, size, len, c; int filehandle; sock1 = tcp_listen(INADDR_ANY, atoi(argv[1]), 5); len = sizeof(client); sock2 = accept(sock1, (struct sockaddr*)&amp;client, &amp;len); while (1) { recv(sock2, buf, 100, 0); sscanf(buf, &quot;%s&quot;, command); if (!strcmp(command, &quot;ls&quot;)) {//ls명령어를 입력받았다면 system(&quot;ls &gt;temps.txt&quot;); stat(&quot;temps.txt&quot;, &amp;obj); size = obj.st_size; send(sock2, &amp;size, sizeof(int), 0); filehandle = open(&quot;temps.txt&quot;, O_RDONLY); sendfile(sock2, filehandle, NULL, size); } else if (!strcmp(command, &quot;get&quot;)) {//get명령어를 입력받았다면 sscanf(buf, &quot;%s%s&quot;, filename, filename); stat(filename, &amp;obj); filehandle = open(filename, O_RDONLY); size = obj.st_size; if (filehandle == -1) size = 0; send(sock2, &amp;size, sizeof(int), 0); if (size) sendfile(sock2, filehandle, NULL, size); } else if (!strcmp(command, &quot;put&quot;)) {//put명령어를 입력받았다면 int c = 0, len; char *f; sscanf(buf + strlen(command), &quot;%s&quot;, filename); recv(sock2, &amp;size, sizeof(int), 0); while (1) { filehandle = open(filename, O_CREAT | O_EXCL | O_WRONLY, 0666); if (filehandle == -1) sprintf(filename + strlen(filename), &quot;_1&quot;); else break; } f = malloc(size); recv(sock2, f, size, 0); c = write(filehandle, f, size); close(filehandle); send(sock2, &amp;c, sizeof(int), 0); } else if (!strcmp(command, &quot;pwd&quot;)) {//pwd명령어를 입력받았다면 system(&quot;pwd&gt;temp.txt&quot;); i = 0; FILE*f = fopen(&quot;temp.txt&quot;, &quot;r&quot;); while (!feof(f)) buf[i++] = fgetc(f); buf[i - 1] = '\\0'; fclose(f); send(sock2, buf, 100, 0); } else if (!strcmp(command, &quot;cd&quot;)) {//cd명령어를 입력받았다면 if (chdir(buf + 3) == 0) c = 1; else c = 0; send(sock2, &amp;c, sizeof(int), 0); } else if (!strcmp(command, &quot;bye&quot;) || !strcmp(command, &quot;quit&quot;)) { //종료 명령어를 입력받았다면 printf(&quot;FTP server quitting..\\n&quot;); i = 1; send(sock2, &amp;i, sizeof(int), 0); exit(0); } } return 0;} FTP Client컴파일 및 실행 방법12$ gcc -o client client.c$ ./client 127.0.0.1 9999 client.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/sendfile.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#define MAXLINE 511int tcp_connect(int af, char *servip, unsigned short port) { struct sockaddr_in servaddr; int s; // 소켓 생성 if ((s = socket(af, SOCK_STREAM, 0)) &lt; 0) return -1; // 채팅 서버의 소켓주소 구조체 servaddr 초기화 bzero((char *)&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = af; inet_pton(AF_INET, servip, &amp;servaddr.sin_addr); servaddr.sin_port = htons(port); // 연결요청 if (connect(s, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) return -1; return s;}int main(int argc, char *argv[]){ struct sockaddr_in server; struct stat obj; int sock; char bufmsg[MAXLINE]; char buf[100], command[5], filename[MAXLINE], *f; char temp[20]; int k, size, status; int filehandle; if (argc != 3) { printf(&quot;사용법 : %s server_ip port\\n&quot;, argv[0]); exit(1); } sock = tcp_connect(AF_INET, argv[1], atoi(argv[2])); if (sock == -1) { printf(&quot;tcp_connect fail&quot;); exit(1); } while (1) { printf(&quot;\\033[1;33m명령어 : get, put, pwd, ls, cd, quit\\n&quot;); printf(&quot;\\033[1;32mclient&gt; &quot;); fgets(bufmsg, MAXLINE, stdin); //명령어 입력 fprintf(stderr, &quot;\\033[97m&quot;); //글자색을 흰색으로 변경 if (!strcmp(bufmsg, &quot;get\\n&quot;)) {//get명령어를 입력받았다면 printf(&quot;다운로드할 파일 : &quot;); scanf(&quot;%s&quot;, filename); //파일 이름 입력 fgets(temp, MAXLINE, stdin); //버퍼에 남은 엔터 제거 strcpy(buf, &quot;get &quot;); strcat(buf, filename); send(sock, buf, 100, 0); //명령어 전송 recv(sock, &amp;size, sizeof(int), 0); if (!size) {//파일이 없다면 printf(&quot;파일이 없습니다\\n&quot;); continue; } f = malloc(size); recv(sock, f, size, 0); while (1) { filehandle = open(filename, O_CREAT | O_EXCL | O_WRONLY, 0666); if (filehandle == -1) //같은 이름이 있다면 이름 끝에 _1 추가 sprintf(filename + strlen(filename), &quot;_1&quot;); else break; } write(filehandle, f, size, 0); close(filehandle); printf(&quot;다운로드 완료\\n&quot;);//전송이 잘 되었다면 } else if (!strcmp(bufmsg, &quot;put\\n&quot;)) {//put명령어를 입력받았다면 printf(&quot;업로드할 파일 : &quot;); scanf(&quot;%s&quot;, filename); //파일 이름 입력 fgets(temp, MAXLINE, stdin); //버퍼에 남은 엔터 제거 filehandle = open(filename, O_RDONLY); if (filehandle == -1) {//파일이 없다면 printf(&quot;파일이 없습니다.\\n&quot;); continue; } strcpy(buf, &quot;put &quot;); strcat(buf, filename); send(sock, buf, 100, 0); stat(filename, &amp;obj); size = obj.st_size; send(sock, &amp;size, sizeof(int), 0);//명령어 전송 sendfile(sock, filehandle, NULL, size);//파일 전송 recv(sock, &amp;status, sizeof(int), 0); if (status)//업로드가 잘 되었다면 printf(&quot;업로드 완료\\n&quot;); else printf(&quot;업로드 실패\\n&quot;); } else if (!strcmp(bufmsg, &quot;pwd\\n&quot;)) {//pwd명령어를 입력받았다면 strcpy(buf, &quot;pwd&quot;); send(sock, buf, 100, 0); recv(sock, buf, 100, 0); printf(&quot;--The path of the Remote Directory--\\n%s&quot;, buf); } else if (!strcmp(bufmsg, &quot;ls\\n&quot;)) {//ls명령어를 입력받았다면 strcpy(buf, &quot;ls&quot;); send(sock, buf, 100, 0); recv(sock, &amp;size, sizeof(int), 0); f = malloc(size); recv(sock, f, size, 0); filehandle = creat(&quot;temp.txt&quot;, O_WRONLY); write(filehandle, f, size, 0); close(filehandle); printf(&quot;--The Remote Directory List--\\n&quot;); system(&quot;cat temp.txt&quot;); //현재 디렉토리의 파일 출력 } else if (!strcmp(bufmsg, &quot;cd\\n&quot;)) {//cd명령어를 입력받았다면 strcpy(buf, &quot;cd &quot;); printf(&quot;이동할 경로 이름 : &quot;); scanf(&quot;%s&quot;, buf + 3); //위치 입력 fgets(temp, MAXLINE, stdin); //버퍼에 남은 엔터 제거 send(sock, buf, 100, 0); //명령어 전송 recv(sock, &amp;status, sizeof(int), 0); if (status) printf(&quot;경로 변경 완료\\n&quot;); else printf(&quot;경로 변경 실패\\n&quot;); } else if (!strcmp(bufmsg, &quot;quit\\n&quot;)) {//quit명령어를 입력받았다면 strcpy(buf, &quot;quit&quot;); send(sock, buf, 100, 0); recv(sock, &amp;status, 100, 0); if (status) { printf(&quot;서버를 닫는 중..\\n&quot;); exit(0); } printf(&quot;서버 닫기 실패\\n&quot;); } }}","link":"/2018/06/03/ftp/"},{"title":"constexpr","text":"constexprconstexpr은 C++11부터 지원하며, Visual Studio 2015부터 사용할 수 있다. 이번에 프로젝트 시연을 하는데, 내 개발환경은 2015 였고, 실습실은 2012 라서 시연을 못했다. 실행파일이라도 가져갔어야 했는데 멍청했다. 그리고 난 망했다..ㅜㅜ 사용법은 여기를 참고하자. 그리고 호환성 부분도 살펴보자.","link":"/2018/06/25/constexpr/"},{"title":"Javascript Array 가공 map(), filter(), find(), reduce()","text":"map()배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환합니다. 1234567891011const array1 = [1, 4, 9, 16];const array2 = [{ id: 1, value: 'a'}, { id: 2}, { id: 3, value: 'b'}];const map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32]const map2 = array2.map(item =&gt; item.value);console.log(map2);// expected output: Array ['a', undefined, 'b'] https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map filter()주어진 함수의 테스트를 통과하는 모든 요소를 모아 새로운 배열로 반환합니다. 12345const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;] https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter find()메서드는 주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환합니다. 그런 요소가 없다면 undefined를 반환합니다. 12345const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];const result = words.find(word =&gt; word.length &gt; 6);console.log(result);// expected output: &quot;exuberant&quot; https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/find reduce()배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하고, 하나의 결과값을 반환합니다 1234567891011const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce","link":"/2020/05/23/map-filter-find-reduce/"},{"title":"Linux에서 Socket으로 채팅구현하기","text":"서버를 구동시킨 후 클라이언트를 실행합니다.클라이언트는 2개 이상 실행이 가능하며 단체 대화방 처럼 사용이 가능합니다.서버에서 지원하는 명령어는 아래와 같습니다.help num_user num_chat ip_list Server컴파일 및 실행 방법 12$ gcc -o server server.c -lpthread$ ./server 9999 소스코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;strings.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/file.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;pthread.h&gt;#define MAXLINE 511#define MAX_SOCK 1024 // 솔라리스의 경우 64char *EXIT_STRING = &quot;exit&quot;; // 클라이언트의 종료요청 문자열char *START_STRING = &quot;Connected to chat_server \\n&quot;;// 클라이언트 환영 메시지int maxfdp1; // 최대 소켓번호 +1int num_user = 0; // 채팅 참가자 수int num_chat = 0; // 지금까지 오간 대화의 수int clisock_list[MAX_SOCK]; // 채팅에 참가자 소켓번호 목록char ip_list[MAX_SOCK][20]; //접속한 ip목록int listen_sock; // 서버의 리슨 소켓 // 새로운 채팅 참가자 처리void addClient(int s, struct sockaddr_in *newcliaddr);int getmax(); // 최대 소켓 번호 찾기void removeClient(int s); // 채팅 탈퇴 처리 함수int tcp_listen(int host, int port, int backlog); // 소켓 생성 및 listenvoid errquit(char *mesg) { perror(mesg); exit(1); }time_t ct;struct tm tm;void *thread_function(void *arg) { //명령어를 처리할 스레드 int i; printf(&quot;명령어 목록 : help, num_user, num_chat, ip_list\\n&quot;); while (1) { char bufmsg[MAXLINE + 1]; fprintf(stderr, &quot;\\033[1;32m&quot;); //글자색을 녹색으로 변경 printf(&quot;server&gt;&quot;); //커서 출력 fgets(bufmsg, MAXLINE, stdin); //명령어 입력 if (!strcmp(bufmsg, &quot;\\n&quot;)) continue; //엔터 무시 else if (!strcmp(bufmsg, &quot;help\\n&quot;)) //명령어 처리 printf(&quot;help, num_user, num_chat, ip_list\\n&quot;); else if (!strcmp(bufmsg, &quot;num_user\\n&quot;))//명령어 처리 printf(&quot;현재 참가자 수 = %d\\n&quot;, num_user); else if (!strcmp(bufmsg, &quot;num_chat\\n&quot;))//명령어 처리 printf(&quot;지금까지 오간 대화의 수 = %d\\n&quot;, num_chat); else if (!strcmp(bufmsg, &quot;ip_list\\n&quot;)) //명령어 처리 for (i = 0; i &lt; num_user; i++) printf(&quot;%s\\n&quot;, ip_list[i]); else //예외 처리 printf(&quot;해당 명령어가 없습니다.help를 참조하세요.\\n&quot;); }}int main(int argc, char *argv[]) { struct sockaddr_in cliaddr; char buf[MAXLINE + 1]; //클라이언트에서 받은 메시지 int i, j, nbyte, accp_sock, addrlen = sizeof(struct sockaddr_in); fd_set read_fds; //읽기를 감지할 fd_set 구조체 pthread_t a_thread; if (argc != 2) { printf(&quot;사용법 :%s port\\n&quot;, argv[0]); exit(0); } // tcp_listen(host, port, backlog) 함수 호출 listen_sock = tcp_listen(INADDR_ANY, atoi(argv[1]), 5); //스레드 생성 pthread_create(&amp;a_thread, NULL, thread_function, (void *)NULL); while (1) { FD_ZERO(&amp;read_fds); FD_SET(listen_sock, &amp;read_fds); for (i = 0; i &lt; num_user; i++) FD_SET(clisock_list[i], &amp;read_fds); maxfdp1 = getmax() + 1; // maxfdp1 재 계산 if (select(maxfdp1, &amp;read_fds, NULL, NULL, NULL) &lt; 0) errquit(&quot;select fail&quot;); if (FD_ISSET(listen_sock, &amp;read_fds)) { accp_sock = accept(listen_sock, (struct sockaddr*)&amp;cliaddr, &amp;addrlen); if (accp_sock == -1) errquit(&quot;accept fail&quot;); addClient(accp_sock, &amp;cliaddr); send(accp_sock, START_STRING, strlen(START_STRING), 0); ct = time(NULL); //현재 시간을 받아옴 tm = *localtime(&amp;ct); write(1, &quot;\\033[0G&quot;, 4); //커서의 X좌표를 0으로 이동 printf(&quot;[%02d:%02d:%02d]&quot;, tm.tm_hour, tm.tm_min, tm.tm_sec); fprintf(stderr, &quot;\\033[33m&quot;);//글자색을 노란색으로 변경 printf(&quot;사용자 1명 추가. 현재 참가자 수 = %d\\n&quot;, num_user); fprintf(stderr, &quot;\\033[32m&quot;);//글자색을 녹색으로 변경 fprintf(stderr, &quot;server&gt;&quot;); //커서 출력 } // 클라이언트가 보낸 메시지를 모든 클라이언트에게 방송 for (i = 0; i &lt; num_user; i++) { if (FD_ISSET(clisock_list[i], &amp;read_fds)) { num_chat++; //총 대화 수 증가 nbyte = recv(clisock_list[i], buf, MAXLINE, 0); if (nbyte &lt;= 0) { removeClient(i); // 클라이언트의 종료 continue; } buf[nbyte] = 0; // 종료문자 처리 if (strstr(buf, EXIT_STRING) != NULL) { removeClient(i); // 클라이언트의 종료 continue; } // 모든 채팅 참가자에게 메시지 방송 for (j = 0; j &lt; num_user; j++) send(clisock_list[j], buf, nbyte, 0); printf(&quot;\\033[0G&quot;); //커서의 X좌표를 0으로 이동 fprintf(stderr, &quot;\\033[97m&quot;);//글자색을 흰색으로 변경 printf(&quot;%s&quot;, buf); //메시지 출력 fprintf(stderr, &quot;\\033[32m&quot;);//글자색을 녹색으로 변경 fprintf(stderr, &quot;server&gt;&quot;); //커서 출력 } } } // end of while return 0;}// 새로운 채팅 참가자 처리void addClient(int s, struct sockaddr_in *newcliaddr) { char buf[20]; inet_ntop(AF_INET, &amp;newcliaddr-&gt;sin_addr, buf, sizeof(buf)); write(1, &quot;\\033[0G&quot;, 4); //커서의 X좌표를 0으로 이동 fprintf(stderr, &quot;\\033[33m&quot;); //글자색을 노란색으로 변경 printf(&quot;new client: %s\\n&quot;, buf);//ip출력 // 채팅 클라이언트 목록에 추가 clisock_list[num_user] = s; strcpy(ip_list[num_user], buf); num_user++; //유저 수 증가}// 채팅 탈퇴 처리void removeClient(int s) { close(clisock_list[s]); if (s != num_user - 1) { //저장된 리스트 재배열 clisock_list[s] = clisock_list[num_user - 1]; strcpy(ip_list[s], ip_list[num_user - 1]); } num_user--; //유저 수 감소 ct = time(NULL); //현재 시간을 받아옴 tm = *localtime(&amp;ct); write(1, &quot;\\033[0G&quot;, 4); //커서의 X좌표를 0으로 이동 fprintf(stderr, &quot;\\033[33m&quot;);//글자색을 노란색으로 변경 printf(&quot;[%02d:%02d:%02d]&quot;, tm.tm_hour, tm.tm_min, tm.tm_sec); printf(&quot;채팅 참가자 1명 탈퇴. 현재 참가자 수 = %d\\n&quot;, num_user); fprintf(stderr, &quot;\\033[32m&quot;);//글자색을 녹색으로 변경 fprintf(stderr, &quot;server&gt;&quot;); //커서 출력}// 최대 소켓번호 찾기int getmax() { // Minimum 소켓번호는 가정 먼저 생성된 listen_sock int max = listen_sock; int i; for (i = 0; i &lt; num_user; i++) if (clisock_list[i] &gt; max) max = clisock_list[i]; return max;}// listen 소켓 생성 및 listenint tcp_listen(int host, int port, int backlog) { int sd; struct sockaddr_in servaddr; sd = socket(AF_INET, SOCK_STREAM, 0); if (sd == -1) { perror(&quot;socket fail&quot;); exit(1); } // servaddr 구조체의 내용 세팅 bzero((char *)&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(host); servaddr.sin_port = htons(port); if (bind(sd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) { perror(&quot;bind fail&quot;); exit(1); } // 클라이언트로부터 연결요청을 기다림 listen(sd, backlog); return sd;} Client컴파일 및 실행 방법 12$ gcc -o client client.c$ ./client 127.0.0.1 9999 nick 소스코드 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;strings.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/time.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#define MAXLINE 1000#define NAME_LEN 20char *EXIT_STRING = &quot;exit&quot;;// 소켓 생성 및 서버 연결, 생성된 소켓리턴int tcp_connect(int af, char *servip, unsigned short port);void errquit(char *mesg) { perror(mesg); exit(1); }int main(int argc, char *argv[]) { char bufname[NAME_LEN]; // 이름 char bufmsg[MAXLINE]; // 메시지부분 char bufall[MAXLINE + NAME_LEN]; int maxfdp1; // 최대 소켓 디스크립터 int s; // 소켓 int namelen; // 이름의 길이 fd_set read_fds; time_t ct; struct tm tm; if (argc != 4) { printf(&quot;사용법 : %s sever_ip port name \\n&quot;, argv[0]); exit(0); } s = tcp_connect(AF_INET, argv[1], atoi(argv[2])); if (s == -1) errquit(&quot;tcp_connect fail&quot;); puts(&quot;서버에 접속되었습니다.&quot;); maxfdp1 = s + 1; FD_ZERO(&amp;read_fds); while (1) { FD_SET(0, &amp;read_fds); FD_SET(s, &amp;read_fds); if (select(maxfdp1, &amp;read_fds, NULL, NULL, NULL) &lt; 0) errquit(&quot;select fail&quot;); if (FD_ISSET(s, &amp;read_fds)) { int nbyte; if ((nbyte = recv(s, bufmsg, MAXLINE, 0)) &gt; 0) { bufmsg[nbyte] = 0; write(1, &quot;\\033[0G&quot;, 4); //커서의 X좌표를 0으로 이동 printf(&quot;%s&quot;, bufmsg); //메시지 출력 fprintf(stderr, &quot;\\033[1;32m&quot;); //글자색을 녹색으로 변경 fprintf(stderr, &quot;%s&gt;&quot;, argv[3]);//내 닉네임 출력 } } if (FD_ISSET(0, &amp;read_fds)) { if (fgets(bufmsg, MAXLINE, stdin)) { fprintf(stderr, &quot;\\033[1;33m&quot;); //글자색을 노란색으로 변경 fprintf(stderr, &quot;\\033[1A&quot;); //Y좌표를 현재 위치로부터 -1만큼 이동 ct = time(NULL); //현재 시간을 받아옴 tm = *localtime(&amp;ct); sprintf(bufall, &quot;[%02d:%02d:%02d]%s&gt;%s&quot;, tm.tm_hour, tm.tm_min, tm.tm_sec, argv[3], bufmsg);//메시지에 현재시간 추가 if (send(s, bufall, strlen(bufall), 0) &lt; 0) puts(&quot;Error : Write error on socket.&quot;); if (strstr(bufmsg, EXIT_STRING) != NULL) { puts(&quot;Good bye.&quot;); close(s); exit(0); } } } } // end of while}int tcp_connect(int af, char *servip, unsigned short port) { struct sockaddr_in servaddr; int s; // 소켓 생성 if ((s = socket(af, SOCK_STREAM, 0)) &lt; 0) return -1; // 채팅 서버의 소켓주소 구조체 servaddr 초기화 bzero((char *)&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = af; inet_pton(AF_INET, servip, &amp;servaddr.sin_addr); servaddr.sin_port = htons(port); // 연결요청 if (connect(s, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) return -1; return s;}","link":"/2018/05/25/socketchat/"},{"title":"Javascript forEach()의 업그레이드 every(), some()","text":"every()배열 안의 모든 요소가 주어진 판별 함수를 통과하는지 테스트합니다. 빈 배열에서 호출하면 무조건 true를 반환합니다. 중간에 통과하지 않는 요소가 있으면( return false인 경우) 더이상 반복하지 않고 종료됩니다. 1234567891011const array1 = [1, 30, 39, 29, 10, 13];const array2 = [1, 30, 41, 29, 10, 13];const result1 = array1.every((currentValue) =&gt; currentValue &lt; 40);console.log(result1);// expected output: trueconst result2 = array2.every((currentValue) =&gt; currentValue &lt; 40);console.log(result2);// expected output: false https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every some()배열 안의 어떤 요소라도 주어진 판별 함수를 통과하는지 테스트합니다. 빈 배열에서 호출하면 무조건 false를 반환합니다. 중간에 어떤 요소라도 통과하면( return true인 경우) 더이상 반복하지 않고 종료됩니다. 1234567891011const array1 = [1, 2, 3, 4, 5];const array2 = [1, 5, 3, 3, 7];const result1 = array1.some((element) =&gt; element % 2 === 0);console.log(result1);// expected output: trueconst result2 = array2.some((element) =&gt; element % 2 === 0);console.log(result2);// expected output: false https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some","link":"/2020/05/23/some-every/"}],"tags":[{"name":"CUDA","slug":"CUDA","link":"/tags/CUDA/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"JUnit","slug":"JUnit","link":"/tags/JUnit/"},{"name":"NHN","slug":"NHN","link":"/tags/NHN/"},{"name":"Diary","slug":"Diary","link":"/tags/Diary/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Game","slug":"Game","link":"/tags/Game/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"OpenMP","slug":"OpenMP","link":"/tags/OpenMP/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"CS188","slug":"CS188","link":"/tags/CS188/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"FTP","slug":"FTP","link":"/tags/FTP/"},{"name":"Messenger","slug":"Messenger","link":"/tags/Messenger/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Oracle","slug":"Oracle","link":"/tags/Oracle/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Chat","slug":"Chat","link":"/tags/Chat/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"Partitioning","slug":"Partitioning","link":"/tags/Partitioning/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Secure","slug":"Secure","link":"/tags/Secure/"},{"name":"Server","slug":"Server","link":"/tags/Server/"},{"name":"Tomcat","slug":"Tomcat","link":"/tags/Tomcat/"},{"name":"Singleton","slug":"Singleton","link":"/tags/Singleton/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Typora","slug":"Typora","link":"/tags/Typora/"},{"name":"Editor","slug":"Editor","link":"/tags/Editor/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"}],"categories":[{"name":"CUDA","slug":"CUDA","link":"/categories/CUDA/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Projects","slug":"Projects","link":"/categories/Projects/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Secure","slug":"Secure","link":"/categories/Secure/"},{"name":"Tomcat","slug":"Tomcat","link":"/categories/Tomcat/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"}]}